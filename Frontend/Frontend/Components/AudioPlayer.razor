@using Audio
@using Common
@using Images
@inject IJSRuntime _jsRuntime;

<audio id="audio" src="@_audioUrl"></audio>

<script>
    window.audioHelper = {
        setAudioElement: (dotnetHelper) => {
            const audio = document.getElementById("audio");

            audio.ontimeupdate = () => {
                if (!isValidAudioTime(audio))
                    return;

                dotnetHelper.invokeMethodAsync("OnAudioProgress", audio.currentTime, audio.duration);
            };

            function isValidAudioTime(audioElement) {
                if (audioElement.currentTime == null || isNaN(audioElement.currentTime) ||
                    audioElement.duration == null || isNaN(audioElement.duration)) {
                    return false;
                }

                return true;
            }
        },
    };

    async function play() {
        const audio = document.getElementById("audio");
        audio.currentTime = 0;

        try {
            await audio.play();
            console.log("Playing new audio");
        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error("Error playing audio:", error);
                dotnetHelper.invokeMethodAsync("OnSkipRequested");
            }
            // AbortError can be safely ignored when switching tracks
        }
    }

    function stop() {
        const audio = document.getElementById("audio");
        audio.pause();
        audio.currentTime = 0;
    }

    function setVolume(volume) {
        document.getElementById("audio").volume = volume;
    }

</script>

@implements IDisposable

@code {
    [Parameter] public SessionState State { get; set; }

    [Inject] private ISongsCollection SongsCollection { get; set; }

    private const double _startOverTime = 1;

    private string _audioUrl = string.Empty;

    private DateTime _lastTimeUpdate;

    private DotNetObjectReference<AudioPlayer>? _dotNetRef;

    protected override void OnInitialized()
    {
        var lifetime = State.Lifetime;

        State.Started.Advise(lifetime, () => Loop().NoAwait());
        State.SkipRequested.Advise(lifetime, OnSkipRequested);
        State.Playlist.Advise(lifetime, OnPlaylistChanged);
        State.Volume.Advise(lifetime, value => OnVolumeChanged(value).NoAwait());
    }

    private async Task Loop()
    {
        _dotNetRef = DotNetObjectReference.Create(this);
        var updateTimeSpan = TimeSpan.FromSeconds(5);

        await _jsRuntime.InvokeVoidAsync("audioHelper.setAudioElement", _dotNetRef);
        await OnVolumeChanged(State.Volume.Value);

        while (State.Lifetime.IsTerminated == false)
        {
            try
            {
                await _jsRuntime.InvokeVoidAsync("stop");
                var url = _audioUrl;
                await InvokeAsync(StateHasChanged);
                await Task.Delay(100, State.Lifetime.Token);
                await _jsRuntime.InvokeVoidAsync("play");

                while (_audioUrl == url &&
                       DateTime.UtcNow - _lastTimeUpdate < updateTimeSpan &&
                       State.Lifetime.IsTerminated == false)
                {
                    await Task.Delay(500, State.Lifetime.Token);
                }

                if (_audioUrl == url)
                    await SetNext();
            }
            catch (Exception e)
            {
                Console.WriteLine(e);

                try
                {
                    await Task.Delay(TimeSpan.FromSeconds(5), State.Lifetime.Token);
                    SetNext().NoAwait();
                }
                catch (OperationCanceledException)
                {
                    // Ignored
                }
            }
        }
    }

    private void OnSkipRequested()
    {
        SetNext().NoAwait();
    }

    private void OnPlaylistChanged()
    {
        SetNext().NoAwait();
    }

    private async Task OnVolumeChanged(double value)
    {
        await _jsRuntime.InvokeAsync<string>("setVolume", Math.Clamp(value / 100, 0, 1));
    }

    [JSInvokable]
    public void OnAudioProgress(double currentTime, double duration)
    {
        var difference = duration - currentTime;
        _lastTimeUpdate = DateTime.UtcNow;

        if (difference >= _startOverTime)
            return;

        SetNext().NoAwait();
    }

    public void Dispose()
    {
        _dotNetRef?.Dispose();
    }

    private async Task SetNext()
    {
        var songData = State.IncSongIndex();
        State.SetCurrentSong(songData);
        _audioUrl = await SongsCollection.GetUrl(songData);
    }

}