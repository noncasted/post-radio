@using Audio
@using Common
@using Images
@inject IJSRuntime _jsRuntime;

<audio id="audio" src="@_audioUrl"></audio>

<script>
    window.audioHelper = {
        setAudioElement: (dotnetHelper) => {
            const audio = document.getElementById("audio");

            audio.ontimeupdate = () => {
                if (!isValidAudioTime(audio))
                    return;

                dotnetHelper.invokeMethodAsync("OnAudioProgress", audio.currentTime, audio.duration);
            };

            function isValidAudioTime(audioElement) {
                if (audioElement.currentTime == null || isNaN(audioElement.currentTime) ||
                    audioElement.duration == null || isNaN(audioElement.duration)) {
                    return false;
                }

                return true;
            }
        },
    };

    async function play() {
        const audio = document.getElementById("audio");
        audio.currentTime = 0;

        try {
            await audio.play();
            console.log("Playing new audio");
        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error("Error playing audio:", error);
                throw error;
            }
            // AbortError can be safely ignored when switching tracks
        }
    }

    function stop() {
        const audio = document.getElementById("audio");
        audio.pause();
        audio.currentTime = 0;
    }

    function setVolume(volume) {
        document.getElementById("audio").volume = volume;
    }

</script>

@implements IDisposable

@code {
    [Parameter] public SessionState State { get; set; }

    [Inject] private ISongsCollection SongsCollection { get; set; }

    private const double _startOverTime = 1;

    private string _audioUrl = string.Empty;

    private TaskCompletionSource _audioCompletion = new();
    private CancellationTokenSource _trackCancellation = new();
    private DotNetObjectReference<AudioPlayer>? _dotNetRef;

    protected override void OnInitialized()
    {
        var lifetime = State.Lifetime;

        State.Started.Advise(lifetime, () => Loop().NoAwait());
        State.SkipRequested.Advise(lifetime, OnSkipRequested);
        State.Playlist.Advise(lifetime, OnPlaylistChanged);
        State.Volume.Advise(lifetime, value => OnVolumeChanged(value).NoAwait());
    }

    private async Task Loop()
    {
        _dotNetRef = DotNetObjectReference.Create(this);

        await _jsRuntime.InvokeVoidAsync("audioHelper.setAudioElement", _dotNetRef);
        await OnVolumeChanged(State.Volume.Value);

        while (State.Lifetime.IsTerminated == false)
        {
            _trackCancellation.Cancel();
            _trackCancellation.Dispose();
            _trackCancellation = new CancellationTokenSource();
            _audioCompletion = new TaskCompletionSource();

            try
            {
                var songData = State.IncSongIndex();

                State.SetCurrentSong(songData);

                await _jsRuntime.InvokeVoidAsync("stop");

                _trackCancellation.Token.ThrowIfCancellationRequested();

                _audioUrl = await SongsCollection.GetUrl(songData);

                _trackCancellation.Token.ThrowIfCancellationRequested();

                await InvokeAsync(StateHasChanged);

                await Task.Delay(100, _trackCancellation.Token);
                await _jsRuntime.InvokeVoidAsync("play");

                await _audioCompletion.Task;
            }
            catch (OperationCanceledException)
            {
                Console.WriteLine("Track playback cancelled");
                // Continue to next track
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                
                try
                {
                    await Task.Delay(TimeSpan.FromSeconds(5), _trackCancellation.Token);
                }
                catch (OperationCanceledException)
                {
                    // Skip delay if cancelled
                }
            }
        }
    }

    private void OnSkipRequested()
    {
        _trackCancellation.Cancel();
        _audioCompletion.TrySetCanceled();
    }

    private void OnPlaylistChanged()
    {
        _trackCancellation.Cancel();
        _audioCompletion.TrySetCanceled();
    }

    private async Task OnVolumeChanged(double value)
    {
        await _jsRuntime.InvokeAsync<string>("setVolume", Math.Clamp(value / 100, 0, 1));
    }

    [JSInvokable]
    public Task OnAudioProgress(double currentTime, double duration)
    {
        var difference = duration - currentTime;

        if (difference >= _startOverTime)
            return Task.CompletedTask;

        _audioCompletion.TrySetCanceled();

        return Task.CompletedTask;
    }

    public void Dispose()
    {
        _trackCancellation?.Cancel();
        _trackCancellation?.Dispose();
        _dotNetRef?.Dispose();
    }

}